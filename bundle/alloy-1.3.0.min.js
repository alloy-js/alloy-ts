/*!
 * MIT License
 *
 * Copyright (c) 2019 Tristan Dyer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).alloy={})}(this,(function(t){"use strict";var e;!function(t){t.Atom="atom",t.Field="field",t.Signature="signature",t.Skolem="skolem",t.Tuple="tuple"}(e||(e={}));class r{constructor(t){this._name=t}name(){return this._name}}class i extends r{constructor(t){super(t),this._skolems=[]}skolems(){return this._skolems.slice()}static addSkolem(t,e){t._skolems.push(e)}}class s extends i{constructor(t,e){super(e),this._type=t}expressionType(){return e.Atom}id(){return this._type.id()+":"+this.name()}isType(t){return this.typeHierarchy().includes(t)}size(){return 1}toString(){return this.name()}type(){return this._type}typeHierarchy(){return this._type.typeHierarchy()}}class n extends i{constructor(t,e){super(`{${e.map(t=>t.name()).join("->")}}`),this._id=t,this._atoms=e}arity(){return this._atoms.length}atoms(){return this._atoms.slice()}equals(t){const e=t.atoms();return this.arity()===t.arity()&&this.atoms().map((t,r)=>e[r]===t).reduce((t,e)=>t&&e,!0)}expressionType(){return e.Tuple}id(){return this._id}size(){return 1}toString(){return this.name()}types(){return this._atoms.map(t=>t.type())}static buildFieldTuple(t,e){let r=n._getTupleAtoms(t,e),i=e[0].id()+"<:"+r.map(t=>t.name()).join("->");return new n(i,r)}static buildSkolemTuple(t,e,r){let i=n._getTupleAtoms(e,r),s=t+"<:"+i.map(t=>t.name()).join("->");return new n(s,i)}static _getTupleAtoms(t,e){let r=Array.from(t.querySelectorAll("atom")).map(t=>t.getAttribute("label"));if(r.includes(null))throw Error("Atom has no label attribute");let i=r.map((t,r)=>e[r].findAtom(t));if(i.includes(null))throw Error("Unable to find all atoms in tuple");return i}}class o extends r{constructor(t,e,r,i,s){if(super(t),this._types=e,this._tuples=r,this._is_meta=i||!1,this._is_private=s||!1,e.length<2)throw Error(`Field ${t} has arity less than two.`);r.forEach(t=>{t.atoms().forEach((r,i)=>{if(!r.isType(e[i]))throw Error(`Tuple ${t} has incorrect types.`)})})}arity(){return this._types.length}expressionType(){return e.Field}id(){return this._types[0].name()+"<:"+this.name()}is_meta(){return this._is_meta}is_private(){return this._is_private}parent(){return this._types[0]}size(){return this._tuples.length}toString(){return this.name()}tuples(){return this._tuples.slice()}types(){return this._types.slice()}static buildFields(t,e){let r=new Map;return t.map(t=>o._buildField(t,e)).forEach(t=>r.set(t.id,t.field)),r}static _buildField(t,e){let r=t.getAttribute("ID"),i=t.getAttribute("parentID"),s=t.getAttribute("label"),l=t.querySelector("types"),u="yes"===t.getAttribute("meta"),a="yes"===t.getAttribute("private");if(!r)throw Error("Field has no ID attribute");if(!i)throw Error("Field has no parentID attribute");if(!s)throw Error("Field has no label attribute");if(!l)throw Error("Field has no types");if(!e.get(parseInt(i)))throw Error("Field parent type has not been created");let h=Array.from(l.querySelectorAll("type")).map(t=>t.getAttribute("ID"));if(h.includes(null))throw Error("Undefined type in field");let p=h.map(t=>e.get(parseInt(t)));if(p.includes(void 0))throw Error("A field type has not been created");let m=Array.from(t.querySelectorAll("tuple")).map(t=>n.buildFieldTuple(t,p)),c=new o(s,p,m,u,a);return{id:parseInt(r),field:c}}}!function(t){function e(t){let e=t.querySelector("type");if(!e)throw Error("Element is not a subset signature");let r=e.getAttribute("ID");if(!r)throw Error("Element is not a subset signature");return parseInt(r)}t.filterExcludeLabels=function(...t){return e=>{let r=e.getAttribute("label");return!!r&&!t.includes(r)}},t.isSubset=function(t){return"sig"===t.tagName&&!!t.querySelector("type")},t.sortSubset=function(t,r){let i=t.getAttribute("ID"),s=r.getAttribute("ID"),n=e(t),o=e(r);if(!i||!s)throw Error("Element has no ID");return o===parseInt(i)?-1:n===parseInt(s)?1:0},t.subsetTypeID=e}(t.xml||(t.xml={}));var l,u,a=t.xml.filterExcludeLabels,h=t.xml.isSubset,p=t.xml.sortSubset,m=t.xml.subsetTypeID;class c extends r{constructor(t,e,r,i,s,n){super(t),this._type=null,this._subtypes=[],this._atoms=[],this._fields=[],this._is_builtin=e||!1,this._is_meta=r||!1,this._is_one=i||!1,this._is_private=s||!1,this._is_subset=n||!1}atoms(t){return t?this.atoms().concat(this.subTypes(!0).reduce((t,e)=>t.concat(e.atoms()),[])):this._atoms.slice()}depth(){return this.typeHierarchy().length-1}each(t){let e,r,i,s,n=this,o=[n];do{for(e=o.reverse(),o=[];n=e.pop();)if(t(n),r=n.subTypes())for(i=0,s=r.length;i<s;++i)o.push(r[i])}while(o.length);return this}eachAfter(t){return this._subtypes.forEach(e=>{e.eachAfter(t)}),t(this),this}eachBefore(t){return t(this),this._subtypes.forEach(e=>{e.eachBefore(t)}),this}expressionType(){return e.Signature}fields(){return this._fields.slice()}findAtom(t){let e,r,i,s,n,o=this,l=[o];do{for(e=l.reverse(),l=[];o=e.pop();){if(n=o._atoms.find(e=>e.name()===t))return n;if(r=o.subTypes())for(i=0,s=r.length;i<s;++i)l.push(r[i])}}while(l.length);return null}id(){return this.name()}isBuiltin(){return this._is_builtin}isMeta(){return this._is_meta}isOne(){return this._is_one}isPrivate(){return this._is_private}isSubset(){return this._is_subset}size(){return this.atoms().length}subTypes(t){return t?this.subTypes().concat(this._subtypes.map(t=>t.subTypes(!0)).reduce((t,e)=>t.concat(e),[])):this._subtypes.slice()}toString(){return this.name()}typeHierarchy(){let t=this._type?this._type.typeHierarchy():[];return t.push(this),t}static assignFields(t){t.forEach(t=>{t.parent()._fields.push(t)})}static buildSigs(t,e,r){let i=new Map,s=new Map,n=r.find(t=>"Int"===t.getAttribute("label")),o=r.find(t=>"seq/Int"===t.getAttribute("label"));if(!n)throw Error("No Int signature found in XML");if(!o)throw Error("No seq/Int signature found in XML");let l=c._buildInt(t,n),u=c._buildSeq(e,o,l.sig);return i.set(l.id,l.sig),i.set(u.id,u.sig),r.filter(a("Int","seq/Int")).filter(t=>!h(t)).forEach(t=>{let e=c._buildSig(t);i.set(e.id,e.sig),e.parentID&&s.set(e.id,e.parentID)}),r.filter(t=>h(t)).sort(p).forEach(t=>{let e=c._buildSub(t,i);i.set(e.id,e.sig),e.parentID&&s.set(e.id,e.parentID)}),s.forEach((t,e)=>{let r=i.get(t),s=i.get(e);if(!r||!s)throw Error("Error parsing parents");s._type=r,r._subtypes.push(s)}),i}static _buildInt(t,e){if(!e)throw Error("Instance contains no Int element");if(t<1)throw Error(`Invalid bitwidth ${t}`);let r=e.getAttribute("ID");if(!r)throw Error("Invalid Int element");let i=new c("Int",!0),n=2**t;for(let t=-n/2;t<n/2;++t)i._atoms.push(new s(i,t.toString()));return{id:parseInt(r),sig:i}}static _buildSeq(t,e,r){if(!e)throw Error("Instance contains no seq/Int element");let i=e.getAttribute("ID");if(!i)throw Error("Invalid seq/Int element");let s=new c("seq/Int",!0,!1,!1,!1,!0);s._type=r;for(let e=0;e<t;++e){let t=r.findAtom(e.toString());if(!t)throw Error("The maxseq value is invalid");s._atoms.push(t)}return{id:parseInt(i),sig:s}}static _buildSig(t){if(!t)throw Error("Signature element does not exist");let e=t.getAttribute("ID");if(!e)throw Error("Signature element has no ID attribute");let r=t.getAttribute("label");if(!r)throw Error("Signature element has no label attribute");let i=t.getAttribute("parentID"),n="yes"===t.getAttribute("builtin"),o="yes"===t.getAttribute("meta"),l="yes"===t.getAttribute("one"),u="yes"===t.getAttribute("private"),a=h(t);if(a)throw Error("Subset signature must be built using AlloySignature._buildSub()");let p=new c(r,n,o,l,u,a);return t.querySelectorAll("atom").forEach(t=>{let e=t.getAttribute("label");if(!e)throw Error("Atom does not have a label");p._atoms.push(new s(p,e))}),i?{id:parseInt(e),parentID:parseInt(i),sig:p}:{id:parseInt(e),sig:p}}static _buildSub(t,e){if(!t)throw Error("Signature element does not exist");let r=t.getAttribute("ID");if(!r)throw Error("Signature element has no ID attribute");let i=t.getAttribute("label");if(!i)throw Error("Signature element has no label attribute");let s=m(t),n="yes"===t.getAttribute("builtin"),o="yes"===t.getAttribute("meta"),l="yes"===t.getAttribute("one"),u="yes"===t.getAttribute("private"),a=h(t);if(!a)throw Error("Signatures must be built using AlloySignature._buildSig()");let p=e.get(s);if(!p)throw Error("Unable to find parent of subset signature");let d=new c(i,n,o,l,u,a);return t.querySelectorAll("atom").forEach(t=>{let e=t.getAttribute("label");if(!e)throw Error("Atom does not have a label");let r=p.findAtom(e);if(!r)throw Error(`Parent signature doesn not contain atom ${e}`);d._atoms.push(r)}),{id:parseInt(r),parentID:s,sig:d}}}class d extends r{constructor(t,e,r){super(t),this._types=e,this._tuples=r}arity(){return this._types.length}expressionType(){return e.Skolem}id(){return this.name()}size(){return this._tuples.length}toString(){return this.name()}tuples(){return this._tuples.slice()}types(){return this._types.slice()}static buildSkolem(t,e,r){let i=new Map;return t.map(t=>d._buildSkolem(t,e,r)).forEach(t=>i.set(t.id,t.skolem)),i}static _buildSkolem(t,e,r){let i=t.getAttribute("ID"),o=t.getAttribute("label"),l=t.querySelector("types");if(!i)throw Error("Skolem has no ID attribute");if(!o)throw Error("Skolem has no label attribute");if(!l)throw Error("Skolem has no type(s)");let u=Array.from(l.querySelectorAll("type")).map(t=>t.getAttribute("ID"));if(u.includes(null))throw Error("Undefined type in skolem");let a=u.map(t=>e.get(parseInt(t)));if(a.includes(void 0))throw Error("A skolem type has not been created");let h=Array.from(t.querySelectorAll("tuple")).map(t=>n.buildSkolemTuple(o,t,a)),p=new d(o,a,h);return 1===a.length?h.forEach(t=>{t.atoms().forEach(t=>{s.addSkolem(t,p)})}):a.length>1&&Array.from(r.values()).forEach(t=>{t.tuples().forEach(t=>{h.find(e=>t.equals(e))&&n.addSkolem(t,p)})}),{id:parseInt(i),skolem:p}}}class f{constructor(t,e){this._filename=t,this._source=e}filename(){return this._filename}source(){return this._source}static fromElement(t){let e=t.getAttribute("filename"),r=t.getAttribute("content");if(!e)throw Error("No filename attribute in XML file");if(!r)throw Error("No source attribute in XML file");return new f(e,r)}}(l=t.filtering||(t.filtering={})).keepAtoms=function(t){return t.expressionType()===e.Atom},l.keepBuiltins=function(t){return t.expressionType()===e.Signature&&t.isBuiltin()},l.keepEmptys=function(t){return 0===t.size()},l.keepFields=function(t){return t.expressionType()===e.Field},l.keepSignatures=function(t){return t.expressionType()===e.Signature},l.keepSkolems=function(t){return t.expressionType()===e.Skolem},l.keepTuples=function(t){return t.expressionType()===e.Tuple},l.removeAtoms=function(t){return t.expressionType()!==e.Atom},l.removeBuiltins=function(t){return!(t.expressionType()===e.Signature&&t.isBuiltin())},l.removeEmptys=function(t){return t.size()>0},l.removeFields=function(t){return t.expressionType()!==e.Field},l.removeSignatures=function(t){return t.expressionType()!==e.Signature},l.removeSkolems=function(t){return t.expressionType()!==e.Skolem},l.removeTuples=function(t){return t.expressionType()!==e.Tuple},(u=t.sorting||(t.sorting={})).alphabeticalSort=function(t,e=!0){const r=e?1:-1;return t=t||(t=>t.name()),(e,i)=>{const s=t(e),n=t(i);return s<n?-r:n<s?r:0}},u.builtinSort=function(t=!0){const e=t?1:-1;return(t,r)=>{const i="signature"===t.expressionType(),s="signature"===r.expressionType();if(i===s){if(!i)return 0;const s=t.isBuiltin();return s===r.isBuiltin()?0:s?e:-e}{const n=i&&t.isBuiltin(),o=s&&r.isBuiltin();return n?e:o?-e:0}}},u.groupSort=function(t){return t=t||[e.Signature,e.Atom,e.Field,e.Tuple,e.Skolem],(e,r)=>t.indexOf(e.expressionType())-t.indexOf(r.expressionType())},u.sizeSort=function(t=!0){const e=t?1:-1;return(t,r)=>(t.size()-r.size())*e},t.AlloyAtom=s,t.AlloyElement=r,t.AlloyField=o,t.AlloyInstance=class{constructor(t){this._bitwidth=0,this._builddate=new Date(0),this._command="",this._filename="",this._maxseq=0,this._sources=[];let e=(new DOMParser).parseFromString(t,"application/xml");this._parseAlloyAttributes(e.querySelector("alloy")),this._parseInstanceAttributes(e.querySelector("instance")),this._parseSourceCode(Array.from(e.querySelectorAll("source")));let r=Array.from(e.querySelectorAll("sig")),i=Array.from(e.querySelectorAll("field")),s=Array.from(e.querySelectorAll("skolem")),n=c.buildSigs(this._bitwidth,this._maxseq,r),l=o.buildFields(i,n),u=d.buildSkolem(s,n,l);c.assignFields(Array.from(l.values())),this._signatures=Array.from(n.values()),this._fields=Array.from(l.values()),this._skolems=Array.from(u.values()),this._xml=new f("XML",t)}atoms(){return this.signatures().filter(t=>!t.isSubset()).map(t=>t.atoms()).reduce((t,e)=>t.concat(e),[])}bidwidth(){return this._bitwidth}builddate(){return new Date(this._builddate.getTime())}command(){return this._command}fields(){return this._fields.slice()}filename(){return this._filename}maxseq(){return this._maxseq}signatures(){return this._signatures.slice()}skolems(){return this._skolems.slice()}sources(){return this._sources.slice()}tuples(t=!1){let e=t?this.skolems().map(t=>t.tuples()).reduce((t,e)=>t.concat(e),[]):[];return this.fields().map(t=>t.tuples()).reduce((t,e)=>t.concat(e),[]).concat(e)}univ(){return this._signatures.find(t=>"univ"===t.name())}xml(){return this._xml}_parseAlloyAttributes(t){if(!t)throw Error("Instance does not contain Alloy info");let e=t.getAttribute("builddate");if(!e)throw Error("Instance does not contain an Alloy build date");this._builddate=new Date(Date.parse(e))}_parseInstanceAttributes(t){if(!t)throw Error("Instance does not contain attribute info");let e=t.getAttribute("bitwidth");if(!e)throw Error("Instance does not contain a bit width");this._setBitWidth(parseInt(e));let r=t.getAttribute("maxseq");if(!r)throw Error("Instance does not contain a max seq");this._setMaxSeq(parseInt(r));let i=t.getAttribute("command");if(!i)throw Error("Instance does not contain a command");this._setCommand(i);let s=t.getAttribute("filename");if(!s)throw Error("Instance does not contain a filename");this._setFilename(s)}_parseSourceCode(t){this._sources=t.map(t=>f.fromElement(t))}_setBitWidth(t){this._bitwidth=t}_setCommand(t){this._command=t}_setFilename(t){this._filename=t}_setMaxSeq(t){this._maxseq=t}},t.AlloySignature=c,t.AlloySkolem=d,t.AlloySource=f,t.AlloyTuple=n,Object.defineProperty(t,"__esModule",{value:!0})}));